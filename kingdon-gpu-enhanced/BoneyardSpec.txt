Here is a comprehensive design document outlining how the PhaseSpace GA Engine will be used to create the "Boneyard" application.

This document synthesizes all our previous discussions, including the core concept of the Boneyard, the technical capabilities of the PhaseSpace GA Engine, and the integration of the FABRIK algorithm as a high-speed solver.

Design Document: The PhaseSpace Boneyard Application

Version: 1.0
Date: July 24, 2025

1. Vision and Goals

The PhaseSpace Boneyard will be a high-fidelity biomechanical simulation and analysis platform built on the computational power of the PhaseSpace GA Engine. It will serve animators, clinical therapists, and researchers by providing a tool that moves beyond the simplifications of traditional skeletal models.

Core Objectives:

Anatomical Completeness: To model and simulate a fully articulated human skeleton, including individual vertebrae, phalanges, and the radius/ulna complex.

Physical Realism: To simulate motion based not just on kinematics, but on physical properties like mass, inertia, and soft-tissue constraints (ligament stiffness, joint damping).

High-Performance Analysis: To provide a comprehensive suite of tools for measuring and quantifying motion, including angles, range of motion (ROM), velocity, and complex phenomena like tremors.

Flexible Solver Architecture: To combine the mathematical rigor of Geometric Algebra with the speed of heuristic solvers like FABRIK to support both offline analysis and real-time interaction.

2. System Architecture

The Boneyard will be a Python application layer built directly on top of the PhaseSpace GA Engine. It will extend the engine's generic adapters into a specialized, anatomically-aware system.

Generated code
+-------------------------------------------------------------+
|                Boneyard Application Layer                   |
|-------------------------------------------------------------|
|  GUI (e.g., PyQt/PySide), Data Visualization (e.g., VTK)    |
|-------------------------------------------------------------|
|  [BoneyardSolver] [MotionAnalysisToolkit] [DataIO Module]   |
|        ↑                ↑                  ↑                |
|  [Skeleton] ↔ [AnatomicalBone] ↔ [AnatomicalJoint]         |
+-------------------------------------------------------------+
                           ↓ (API Calls)
+-------------------------------------------------------------+
|                 PhaseSpace GA Engine (Library)              |
|-------------------------------------------------------------|
|  [GASkeletalAnimationAdapter]  [GAOpticalSystemAdapter]     |
|-------------------------------------------------------------|
|  [GAEngine] ↔ [NumPy Backend] ↔ [CuPy GPU Backend]          |
|-------------------------------------------------------------|
|           Embedded Kingdon GA Library (Core Math)           |
+-------------------------------------------------------------+


The Boneyard application is the user-facing product; the PhaseSpace GA Engine is its core dependency.

3. Boneyard Application Components

These are the primary Python classes to be developed for the Boneyard application.

3.1. AnatomicalBone

A data-rich object representing a single rigid body in the skeleton. It extends the concept of the Bone class from the animation adapter.

Properties:

name: (string) e.g., "femur_L"

geometry: (Mesh data) For rendering.

mass: (float) Estimated mass.

inertia_tensor: (GA Multivector or 3x3 Matrix) Resistance to rotation.

parent_joint, child_joints: (string names) Defines connectivity.

State (Dynamic):

motor: (GA Multivector) A single GA object in Conformal Geometric Algebra (CGA) representing the bone's complete position and orientation in world space. This replaces the classic 4x4 matrix.

3.2. AnatomicalJoint

Represents the connection between bones and defines the rules of motion.

Properties:

name: (string) e.g., "knee_L"

joint_type: (Enum) SPHERICAL (hip), REVOLUTE (knee), COMPOUND (spine).

Constraint Model (Geometric Algebra):

rom_cone: (GA Bivector/Plane) For ball joints, defines the cone of allowable motion.

hinge_axis: (GA Line) For revolute joints, defines the axis of rotation.

min_max_angle: (float, float) Limits for hinge rotation.

Physics Properties:

stiffness: (float) Spring constant for resistance at ROM limits.

damping: (float) Frictional force to make motion look natural.

3.3. Skeleton

The container class for the entire articulated model.

Responsibilities:

Holds dictionaries of all AnatomicalBone and AnatomicalJoint objects.

Maintains the kinematic hierarchy (parent/child relationships).

Provides methods to get the state of the entire skeleton or specific chains.

3.4. BoneyardSolver

The core "brain" of the application, orchestrating all motion calculations. It will implement the Strategy Pattern for IK.

Methods:

apply_fk(pose): Applies a forward-kinematics pose to the skeleton.

solve_ik(chain, target, method='hybrid'): The main IK entry point.

If method='hybrid': Use FABRIK for an initial guess, then refine with a GA-based physics step.

If method='fabrik': Use the fast FABRIK solver only (for real-time posing).

If method='ga_physics': Use a full, iterative physics simulation to find the target.

3.5. MotionAnalysisToolkit

A suite of tools for extracting quantitative data from a simulation.

Methods:

calculate_rom(joint, motion_sequence): Measures the actual range of motion from a recorded animation.

measure_angular_velocity(bone, motion_sequence): Calculates peak/average angular velocity.

analyze_tremor(bone, motion_sequence): Performs frequency and amplitude analysis (FFT) on the bone's motion to quantify tremors.

4. Core Workflows
4.1. Forward Kinematics (FK)

A Pose object is defined, specifying target orientations for a set of bones.

The BoneyardSolver traverses the Skeleton hierarchy from the root.

For each bone, its local motor is composed with its parent's world-space motor using GAEngine.geometric_product.

The final world-space motor for each bone is stored in its motor property.

4.2. Inverse Kinematics (IK) - Hybrid Method

This is the primary workflow for goal-oriented tasks.

User Request: BoneyardSolver.solve_ik("hand_L", target_position).

Phase 1: Heuristic Guess (FABRIK)

The solver calls its internal FABRIK implementation (as previously designed).

This step operates on a simplified point-and-stick model, ignoring physics.

Output: A set of joint positions that geometrically satisfy the IK chain.

Phase 2: Conversion to GA

The solver converts the FABRIK-solved positions into a Pose of GA rotors (bivector exponentials). This Pose represents the ideal kinematic solution.

Phase 3: Physical Refinement (GA Physics)

The GA-based pose is applied to the Skeleton.

The solver runs a few steps of a physics simulation. It calculates the forces (torques) required to hold this pose, considering gravity, mass, and the soft constraints of the AnatomicalJoints.

The skeleton "settles" from the perfect kinematic pose into a physically plausible one.

Final Output: A final, physically realistic skeleton state that reaches for the target.

5. Leveraging the PhaseSpace GA Engine

The Boneyard application will make extensive use of the underlying engine's features as defined in the technical specification.

Mathematical Foundation:

All calculations will use the Conformal Geometric Algebra (CGA), signature (4, 1, 0). This allows position and orientation to be unified in a single motor multivector.

Core operations like geometric_product, inverse, and project will be used for all transformations and constraint checks.

Performance:

The CuPy GPU backend will be the default for all large-scale simulations and batch analyses to ensure high performance. The engine's automatic backend selection will be relied upon.

Bone and joint states will be marshaled into MultivectorBatch arrays for efficient, vectorized processing by the engine.

Domain Adapters:

The existing GASkeletalAnimationAdapter will serve as the foundational prototype. The BoneyardSolver is its direct, more powerful and specialized successor.

6. Conclusion

The Boneyard project is a direct and powerful application of the PhaseSpace GA Engine. By layering a specialized, anatomically-aware application on top of the engine's robust mathematical and computational core, we can achieve all stated goals. The proposed hybrid IK solver represents a state-of-the-art approach, blending speed with physical accuracy, and will provide a significant advantage over existing tools in the fields of animation, therapy, and biomechanical research.

Excellent question. Integrating a standard, portable 3D format like .glb is a critical step for making the Boneyard's data useful and accessible. It bridges the gap between our abstract simulation and tangible, visual results.

Here is a detailed explanation of how the .glb format will be used to view the Boneyard's output, integrating with the established design.

Strategy: Decoupling Static Geometry from Dynamic Animation

Our approach will treat the .glb format as a container for two distinct types of data:

The Static Skeleton Model: A "template" file containing the bone hierarchy and their visible 3D meshes. This file is created once and represents the form of the skeleton.

The Dynamic Motion Data: The animation track generated by the Boneyard simulation. This data represents the motion of the skeleton and will be programmatically injected into the static template to create an animated scene.

This decoupling is highly efficient. We don't need to save the mesh geometry in every frame; we only save the compact transformation data.

Part 1: Creating the Static Skeleton Template (base_skeleton.glb)

This is a one-time setup step, performed using a standard Digital Content Creation (DCC) tool like Blender.

Modeling/Importing: Each bone that will be simulated in the Boneyard (AnatomicalBone) will have a corresponding 3D mesh representation. These can be imported from anatomical libraries or custom-modeled.

Hierarchy (Armature): We will construct a skeletal armature in Blender that exactly mirrors the hierarchy in our Boneyard Skeleton class. Each bone in Blender will be named to match the name of the AnatomicalBone in our simulation (e.g., femur_L, tibia_L, C7, pelvis). This naming convention is critical for linking the simulation data later.

Rest Pose (Bind Pose): The skeleton will be set to a standard rest pose (e.g., a T-pose). The transformations of this pose are stored in the glTF file as the Inverse Bind Matrices. This defines the "zero state" from which all our simulated animations will apply.

Exporting: The final model is exported as base_skeleton.glb. This file contains:

Nodes: The hierarchy of all the bones.

Meshes: The vertex data for the visual representation of each bone.

Skins: (Optional but powerful) A skin can be used to bind a single, continuous human mesh to the underlying bone nodes for a more realistic look than just separate floating bones.

This base_skeleton.glb is now our master template. It knows the shape and structure of our subject but contains no motion.

Part 2: Generating Animation Data from the Boneyard Simulation

This is where the Boneyard application does its work. After a simulation runs (e.g., a gait cycle, a therapeutic motion), the output is a time-series of transformation data for each bone.

Simulation Output: The simulation produces a sequence of states. For each frame t:

For each AnatomicalBone: We have a GA motor representing its world-space position and orientation.

Data Conversion: Before export, we must convert the GA motor into the standard format that glTF animations use: translation vectors (vec3) and rotation quaternions (quat).

The PhaseSpace GA Engine will provide a utility function: motor_to_translation_quaternion(motor). This is a standard and efficient conversion.

Keyframe Tracks: We will create keyframe tracks for each animated bone. For a bone like "femur_L", we will generate two arrays:

timestamps: [0.0, 0.033, 0.066, ...] (the time of each simulation frame).

translations: [vec3_frame0, vec3_frame1, vec3_frame2, ...]

rotations: [quat_frame0, quat_frame1, quat_frame2, ...]

This raw keyframe data is what we will programmatically write into the .glb file.

Part 3: Programmatic Export to .glb

We will use a Python library like pygltflib to modify our base_skeleton.glb template without needing to open a DCC tool.

The export process in our Boneyard Python application will be:

Generated python
# (Inside a Boneyard data export module)
import pygltflib
import numpy as np

def export_simulation_to_glb(simulation_data, base_glb_path, output_glb_path):
    # 1. Load the static skeleton template
    gltf = pygltflib.GLTF2.load(base_glb_path)

    # 2. Convert simulation keyframes into binary buffer data
    #    (This involves creating bufferViews and accessors for timestamps,
    #    translations, and rotations for each bone)
    animation_data_blob, accessors = package_animation_data(simulation_data)
    
    # Add the binary animation data to the GLTF buffer
    buffer = gltf.buffers[0]
    buffer.byteLength += len(animation_data_blob)
    gltf.set_binary_blob(gltf.binary_blob() + animation_data_blob)

    # 3. Create the glTF Animation Object
    new_animation = pygltflib.Animation(name="Boneyard Simulation")
    gltf.animations.append(new_animation)

    # 4. Create Channels and Samplers for each animated bone
    for bone_name, bone_anim_data in simulation_data.items():
        # Find the node index for this bone
        node_index = find_node_by_name(gltf, bone_name)

        # Create a sampler for rotation
        rot_sampler = pygltflib.AnimationSampler(
            input=accessors[bone_name]['timestamps'],
            output=accessors[bone_name]['rotations'],
            interpolation="LINEAR"
        )
        new_animation.samplers.append(rot_sampler)

        # Create a channel to apply the rotation to the bone node
        rot_channel = pygltflib.AnimationChannel(
            sampler=len(new_animation.samplers) - 1,
            target=pygltflib.AnimationChannelTarget(node=node_index, path="rotation")
        )
        new_animation.channels.append(rot_channel)
        
        # ... (Repeat for translation) ...

    # 5. Save the final, animated GLB file
    gltf.save(output_glb_path)
    print(f"Successfully saved animated simulation to {output_glb_path}")

Part 4: Viewing the Animated Data

The final output is a self-contained animated_simulation.glb file. Because .glb is a ubiquitous standard, viewing is simple and requires no special software:

Web Browsers: The file can be viewed directly online using viewers like gltf-viewer.donmccurdy.com or integrated into web reports for clients or patients using libraries like Three.js or Babylon.js.

Operating Systems: Modern versions of Windows and macOS have built-in 3D viewers that can open .glb files with a double-click.

DCC Tools: The animated file can be imported back into Blender, 3ds Max, or Cinema 4D for further rendering, analysis, or integration into larger animation projects.

Summary of Advantages of this Workflow

Standardization: The output is a highly portable, industry-standard file.

Efficiency: We only store the lightweight transformation data, keeping file sizes small.

Automation: The process is fully programmatic, fitting perfectly into the Boneyard's analysis and export pipeline.

Accessibility: Clinicians, patients, and collaborators can view the results easily without needing access to the Boneyard software itself.

Decoupling: The core simulation engine remains completely independent of the visualization format, adhering to good software design principles.


Excellent point. This is a crucial step for moving the Boneyard from a generic simulator to a personalized clinical and analytical tool. By incorporating a calibration phase, we can "fit" our generic skeleton to a specific individual, dramatically increasing the accuracy and relevance of any subsequent analysis.

This will be added as a foundational protocol in the Boneyard's operational design. Here's how it will be formally specified.

Design Document Addendum: Section 7 - Subject-Specific Skeleton Calibration Protocol

This section details the workflow for calibrating the generic Boneyard skeleton to match the anthropometry and specific range of motion of an individual user. This protocol is a prerequisite for any clinical or personalized analysis.

7.1. Objective

To programmatically adjust the Boneyard's internal skeleton model—specifically bone lengths and joint constraints—based on a small set of physical measurements and captured motions. This creates a "digital twin" of the user's skeleton.

7.2. The Calibration Workflow

The calibration process is a guided, multi-phase procedure performed once per user.

Inputs:

A single static measurement: The user's total height (or distance from floor to top of head).

A stream of 3D positional data for key joints (e.g., from VR trackers, optical motion capture, or advanced video-based pose estimation).

Output:

A user-specific calibration file (e.g., subject_jane_doe.json) containing the precise bone lengths and joint ROM parameters.

Phase 1: Initial Anthropometric Scaling (Static)

This is a coarse, first-pass adjustment to get the skeleton to the right general size.

Action: The user (or a technician) inputs the user's measured height.

Process:

The Boneyard compares the user's height to the height of the default base_skeleton.glb model.

It calculates an initial scaling factor.

Method: Instead of simple isotropic (uniform) scaling, the Boneyard will use an anthropometric scaling model. It applies the overall height to a statistical database (e.g., based on Dreyfuss or NASA anthropometric data) to predict the most probable lengths for major bones like the femur, humerus, etc.

Result: The base_skeleton is resized to a statistically likely approximation of the user. This is the starting point for the dynamic refinement.

Phase 2: Dynamic Limb Length Refinement (Kinematic)

This phase uses motion to find the true length of each limb segment, overriding the statistical estimates from Phase 1.

Action: The user is prompted to perform a series of slow, deliberate motions with one limb at a time (e.g., "Slowly wave your right arm in large, smooth arcs").

Data Capture: While the user performs the motion, the system records the 3D world positions of the relevant joints (e.g., shoulder, elbow, and wrist).

Process: The Constant Distance Principle

The core insight is that the distance between two adjacent joints is constant and equals the length of the bone connecting them.

To find the length of the upper arm (humerus), the system calculates the Euclidean distance || elbow_position(t) - shoulder_position(t) || for every frame t in the captured motion sequence.

By averaging these hundreds or thousands of measurements, we get an extremely precise, noise-resistant value for the user's actual upper arm length.

Repetition: This process is repeated for all major limb segments:

Forearm: Average distance between wrist and elbow.

Thigh: Average distance between hip and knee.

Shin: Average distance between knee and ankle.

Result: The lengths of the AnatomicalBone objects in the Boneyard's Skeleton are updated with these precise, measured values.

Phase 3: Range of Motion (ROM) Constraint Tuning

Since the user is already performing ROM exercises, we will leverage this data to personalize the joint constraints.

Action: The user is asked to move a joint through its complete, comfortable range of motion (e.g., "Move your arm in the largest possible circle from the shoulder").

Data Capture: We record the motion of the distal bone relative to the proximal bone.

Process: Fitting Geometric Boundaries

For Ball-and-Socket Joints (Shoulder/Hip): The captured motion of the distal joint creates a 3D point cloud. The system fits a geometric cone to this point cloud.

The axis of this cone defines the joint's neutral orientation.

The angle of the cone becomes the rom_cone constraint for that specific AnatomicalJoint.

For Hinge Joints (Knee/Elbow): The system analyzes the motion to find the primary plane of rotation and calculates the minimum and maximum flexion angles. These values become the min_max_angle constraints for the joint.

Result: The generic joint constraints in the Skeleton are replaced with the user's personal, measured ROM, allowing for much more accurate simulation of their specific movement capabilities and limitations.

7.3. Storing and Using the Calibration Data

The final output of this protocol is not a new .glb file. The base geometry remains the same. Instead, we save a lightweight calibration file:

Format: A simple JSON or YAML file, e.g., jane_doe_calibration.json.

Content: This file stores the deltas from the base skeleton:

Generated json
{
  "subject_id": "jane_doe",
  "base_skeleton": "base_skeleton.glb",
  "height": 1.75, // meters
  "bone_lengths": {
    "humerus_L": 0.31,
    "ulna_L": 0.26,
    ...
  },
  "joint_constraints": {
    "shoulder_L": {
      "type": "spherical",
      "rom_cone_angle": 110.5, // degrees
      ...
    }
  }
}


Workflow Integration:
When a user starts a Boneyard session, they will load this calibration file. The application will:

Load the base_skeleton.glb model.

Programmatically apply the bone length and joint constraint values from the calibration file.

Proceed with a Skeleton instance that is now a high-fidelity digital twin of the specific user, ready for accurate simulation and analysis.